#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 5.0.2
#  in conjunction with Tcl version 8.6
#    Mar 18, 2020 07:45:30 PM EDT  platform: Windows NT
#    Mar 19, 2020 11:52:49 AM EDT  platform: Windows NT

import sys

import time, threading, math

try:
    from pyfirmata import Arduino, util
except:
    import pip
    pip.main(['install','pyfirmata'])
    from pyfirmata import Arduino, util
try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True


board = Arduino('COM3') #Confirm port on Rasp. Pi

## Inputs ##
pressure_sensor = board.get_pin('a:0:i')
flow_sensor = board.get_pin('d:2:i')
done_pin = board.get_pin('d:4:i')
spare_input_pin = board.get_pin('d:5:i')

## Outputs ##
beer_selection_0 = board.get_pin('d:7:o')
beer_selection_1 = board.get_pin('d:8:o')
beer_selection_2 = board.get_pin('d:9:o')
estop_pin = board.get_pin('d:3:o')
start_pin = board.get_pin('d:10:o')
spare_output_pin = board.get_pin('d:11:o')
LED = board.get_pin('d:13:o')

def set_Tk_var():
    global CheckSampler,CheckSmall, CheckLarge
    CheckSampler = tk.IntVar()
    CheckSmall = tk.IntVar()
    CheckLarge = tk.IntVar()

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top

############## Added Fuctions ###################################
def READ_DONE_BIT():

    """
    thread = util.Iterator(board)
    thread.start()
    state = done_pin.read()
    
    time.sleep(0.1)

    if state is None: state = False
        
    return state
    """
    return False

def READ_PRESSURE_SENSOR():
    """
    it = util.Iterator(board)
    it.start()
    board.analog[0].enable_reporting()
    pressureVal = pressure_sensor.read()
    time.sleep(.001)
    
    voltage = (pressureVal * 5.0) / 1023
    pressure_pascal = 300000 * (float(voltage) - 0.5)
    pressure_psi = pressure_pascal / 6895
    
    print("Pressure Reading: " + str(pressure_psi) + " psi")
    # return int(pressure_psi)
    """
    return 15.246

def READ_FLOW_RATE_SENSOR():
    pulsecount = 0
    calibration_factor = 140390.3604
    total_MilliLiters = 0.0
    
    Trigger = True
    
    flowReadOld = flow_sensor.read()
    oldTime = time.time()
    thread = util.Iterator(board)
    thread.start()
            
    while(Trigger):
        old = flow_sensor.read()
        time.sleep(.0001)
        if(flow_sensor.read() != old):
            pulsecount = pulsecount + 1
                
        if((time.time() - oldTime) > 1.0):
            print("Pulse Count: " + str(pulsecount))
            
            flow_rate = ((1000.0 / (time.time() - oldTime) * pulsecount) / calibration_factor)
            print("Flow Rate L/min: " + str(flow_rate))

            # Divide the flow rate in liters/minute by 60 to determine
            # how many liters have passed through the sensor in this 1
            # second interval, then multiple by 1000 to covert to mL
            flow_MilliLiters = (flow_rate / 60) * 1000
            
            total_MilliLiters = total_MilliLiters + flow_MilliLiters
            print("Total mL: " + str(total_MilliLiters))

            oldTime = time.time()
            pulsecount = 0
    return int(total_MilliLiters)
 

def WRITE_ESTOP():
    estop_pin.write(1)

def WRITE_GO_BIT(beer_selection_port):
    # Sampler Size
    if beer_selection_port == 0:
        beer_selection_0.write(1)
    # Small Size   
    elif beer_selection_port == 1:
        beer_selection_1.write(1)
    # Large Size 
    elif beer_selection_port == 2:
        beer_selection_2.write(1)

    # Write Go Pin
    start_pin.write(1)
    time.sleep(0.75)
    start_pin.write(0)
    # LED.write(True)
    sys.stdout.flush()

def WRITE_RESET_PORTS():
    estop_pin.write(0)
    beer_selection_0.write(0)
    beer_selection_1.write(0)
    beer_selection_2.write(0)
    start_pin.write(0)
    spare_output_pin.write(0)

def WRITE_LED(state):
    if state:
        LED.write(1)
    else:
        LED.write(0)
    
#######################################################################
def COMMAND_START_POUR(): #Not Used
    print('Kegerator_V4_support.COMMAND_START_POUR')
    sys.stdout.flush()

def COMMAND_STOP_POUR(): #Not Used
    print('Kegerator_V4_support.COMMAND_STOP_POUR')
    sys.stdout.flush()
 
def COMMAND_CLEAN(): #Not Used
    print('Kegerator_V4_support.COMMAND_CLEAN')
    sys.stdout.flush()

def COMMAND_RESET_CUMULATIVE(): #Not Used
    print('Kegerator_V4_support.COMMAND_RESET_CUMULATIVE')
    sys.stdout.flush()

def COMMAND_RESET_KEG_LEVEL(): #Not Used
    print('Kegerator_V4_support.COMMAND_RESET_KEG_LEVEL')
    sys.stdout.flush()

def COMMAND_SAMPLER(): #Not Used
    print('Kegerator_V4_Carbon_support.COMMAND_SAMPLER')
    sys.stdout.flush()

def COMMAND_SMALL(): #Not Used
    print('Kegerator_V4_Carbon_support.COMMAND_SMALL')
    sys.stdout.flush()

def COMMAND_LARGE(): #Not Used
    print('Kegerator_V4_Carbon_support.COMMAND_LARGE')
    sys.stdout.flush()


########################################################################

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import Kegerator_V4
    Kegerator_V4.vp_start_gui()





